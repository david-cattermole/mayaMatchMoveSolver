<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solver Design &#8212; mayaMatchMoveSolver master documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'master',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nodes" href="nodes.html" />
    <link rel="prev" title="Hotkeys" href="tools_hotkeys.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nodes.html" title="Nodes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tools_hotkeys.html" title="Hotkeys"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mayaMatchMoveSolver master documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="solver-design">
<span id="solver-design-heading"></span><h1>Solver Design<a class="headerlink" href="#solver-design" title="Permalink to this headline">¶</a></h1>
<p>Many users of MatchMove software find that by understanding how the
underlying processes of the software work they are able to obtain better
results by utilising the software as it&#8217;s intended to work.</p>
<p>This document tries to answer that question;</p>
<blockquote>
<div><em>How does the MM Solver work?</em></div></blockquote>
<div class="section" id="how-does-the-solver-work">
<span id="solver-design-how-does-it-work"></span><h2>How does the solver work?<a class="headerlink" href="#how-does-the-solver-work" title="Permalink to this headline">¶</a></h2>
<p>The solver inside MM Solver is an <em>optimisation</em> solver. The solver
attempts to optimise the <em>measured error</em> with various <em>unknown
parameter</em> values. The solver&#8217;s purpose is to find the parameter values
which minimise the <em>measured error</em>.</p>
<p>The process of applying an <em>optimisation</em> solver to 3D perspective
cameras, 2D points and 3D points is called Bundle Adjustment (BA). BA is
traditionally the last step of MatchMove and Photogrammetry solvers
where the parameters of 3D points (Bundles) and cameras are solved to
produce a 3D Scene with the least possible error.</p>
</div>
<div class="section" id="attributes">
<span id="solver-design-attributes"></span><h2>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h2>
<p>In the MM Solver, we refer to <em>unknown parameters</em> as Attributes.
Attributes are the Maya attributes that are allowed to be modified
inside the solver. Maya attributes that are not added into the solver
will still be used, but cannot be modified.</p>
<p>The Attributes modified in the MM Solver may be <strong>any</strong> attribute in
Maya. Likewise the attributes may be in any space required, for example;
object-space, world-space or normal/vertex space. The only requirement
is that the Attribute modifies the <em>Bundle</em> position (see below for
detail on <em>Bundles</em>). <em>Bundle</em> positions may be modified indirectly
using hierarchies or rigs of Maya transform nodes. The true power of the
solver comes from the evaluation environment, Maya, and the node
networks/hierarchies created by the MatchMove artist.</p>
<p>Like Maya attributes, MM Solver Attributes can also change over-time
using an <em>animated</em> curve, or just have a single <em>static</em> value, or they
can be be <em>locked</em>. <em>Locked</em> attributes cannot be modified by Maya and
therefore cannot be modified in the solver either. Due to underlying
solving algorithm only floating-point attribute values can be solved.
Commonly solved Attributes are 3D translate and rotate axes.</p>
</div>
<div class="section" id="markers-and-bundles">
<span id="solver-design-markers-and-bundles"></span><h2>Markers and Bundles<a class="headerlink" href="#markers-and-bundles" title="Permalink to this headline">¶</a></h2>
<p><em>Markers</em> and <em>Bundles</em> are used to compute the <em>measured error</em> inside
the solver. The word <em>Marker</em> is used to describe a 2D point on an image
plane, and <em>Bundle</em> to describe the 3D Point.</p>
<p><em>Markers</em> have had different names in various MatchMove software
applications; Track, feature, 2D point, etc. For the purposes of MM
Solver name <em>Marker</em> is used for the tracking markers placed on the set
of a film production. <em>Bundles</em> are named as such because they represent
a bundle of light forming on the imaging sensor.</p>
<p><em>Markers</em> and <em>Bundles</em> are linked together. The <em>Marker</em> is the
representation of the <em>Bundle</em> from a camera&#8217;s point of view. There may
be multiple 2D <em>Marker</em> representations of the same 3D <em>Bundle</em>.</p>
<p>Having known 2D Markers of a 3D Bundle looking through a known
perspective <em>Camera</em> we can calculate a 3D <em>Bundle</em> position by moving
the <em>Bundle</em> until the difference between all Markers and Bundles is
zero when looking through each perspective <em>Camera</em>. Another way to say
this is that the <em>measured error</em> is the distance between the
screen-space re-projected 3D Bundles with the linked 2D Markers.</p>
</div>
<div class="section" id="solving">
<span id="solver-design-solving"></span><h2>Solving<a class="headerlink" href="#solving" title="Permalink to this headline">¶</a></h2>
<p>Once the solver has <em>Attributes</em>, <em>Cameras</em> and <em>Markers</em> and linked
<em>Bundles</em>, the solver can start a solve.</p>
<p>The solver may only start if some conditions are met. One important
condition is the number of Attributes verses the number of Markers or
specifically:</p>
<blockquote>
<div>The number of <em>measured errors</em> must be equal to or greater than the
number of <em>Attribute</em> values you&#8217;re solving.</div></blockquote>
<p>All 3D MatchMove software has this limitation, MM Solver is no
different. There is a minimum number of Markers required to solve for a
3D Camera that can move in 6 degrees of freedom (6 DOF: translate X, Y
and Z, rotate X, Y and Z). For MM Solver this number is a <strong>minimum</strong> of
3 Markers. 3 Markers are required to solve for 6 attributes.</p>
<p>Since each <em>Marker</em> measures 2 errors (X and Y distance to <em>Bundle</em>),
the marker can solve for 2 attributes. For example, 1 <em>Marker</em> can be
used to solve a <em>Camera</em> transform rotate X and Y (tilt and pan)
attributes.</p>
<p>When the user gives a <em>Marker</em> as input for MM Solver, the position is
assumed to be correct. Some 3D MatchMove software applications use many
2D Markers and filter out the badly tracked points (the <em>outliers</em>), MM
Solver does not work like this. Badly tracked <em>Markers</em> will affect the
solve badly.</p>
<p>This solver is an optimiser and it needs to be provided with an
approximation of input attribute values, or in other words; we need to
animate the camera(s), and place the bundles in the roughly correct
positions. You don&#8217;t need to do the job of the solver, which is to make
the <em>Cameras</em> and <em>Bundles</em> match perfectly, but you are required to at
least have <em>Bundles</em> positioned inside the FOV of the camera, and an
approximate animation of the camera if you&#8217;re solving the camera
parameters.</p>
<p>The approximate <em>Camera</em> and <em>Bundle</em> positions is why the MM Solver is
so different from traditional MatchMove solutions, especially
Auto-Tracking 3D MatchMove software; there is no one-click solution. But
this can be a good thing!</p>
<p>Remember the solver is an optimiser and it re-uses the input parameters
and refines them rather than re-starting the solve from scratch. This
type of solver enables customised, layered solving. For example, you may
solve for a small number of individual Attributes with specific sets of
<em>Markers</em> and <em>Bundles</em>, or you could use it in a similar way to other
3D MatchMove software where all parameters are added into the solver.</p>
<p>Due to the inherent refinement nature of the solver, a general process
for solving will be:</p>
<ol class="arabic simple">
<li>Add Cameras, Bundles and Markers.</li>
<li>Track 2D <em>Markers</em>.</li>
<li>Place <em>Cameras</em> and <em>Bundles</em> into approximate positions.</li>
<li>Set up movement constraints or node hierarchies for <em>Cameras</em> and /
or <em>Bundles</em>.</li>
<li>Solve for Attribute values.</li>
<li>Repeat steps 2-5 until desired result is achieved.</li>
</ol>
</div>
<div class="section" id="solving-process">
<span id="solver-design-solving-process"></span><h2>Solving Process<a class="headerlink" href="#solving-process" title="Permalink to this headline">¶</a></h2>
<p>Each time you execute a solve, the solver goes though a number of steps
to perform the optimisation and reduce the error.</p>
<p>This is an overview of the solver&#8217;s process:</p>
<ol class="arabic simple">
<li>Initialises input data.</li>
<li>Solve.<ol class="arabic">
<li>Measure Initial Error.<ol class="arabic">
<li>Set all the initial Attribute values.</li>
<li>Measure the initial re-projection error.</li>
</ol>
</li>
<li>Discover how each Attribute changes the <em>measured error</em>.</li>
<li>Iterate.<ol class="arabic">
<li>Based on the discovered value/error changes predict better
Attribute values.</li>
<li>Set all Attribute values with the predicted Attribute values.</li>
<li>Measure the re-projection error.</li>
<li>Check if the error is low enough, if so stop solving, otherwise
repeat the iteration.</li>
</ol>
</li>
</ol>
</li>
<li>Get solver information.<ol class="arabic">
<li>Set attributes values as calculated.</li>
<li>Measure Final Error.</li>
<li>Get number of iterations.</li>
</ol>
</li>
<li>Return Solver information to the user.</li>
</ol>
<p>The slowest step of the solving process is step 2 as it may be executed
hundreds or thousands of times, depending on the number of <em>Attributes</em>
and <em>Markers</em> that are in the solve.</p>
</div>
<div class="section" id="time-static-and-animated-attributes">
<span id="solver-design-static-and-animated-attributes"></span><h2>Time - Static and Animated Attributes<a class="headerlink" href="#time-static-and-animated-attributes" title="Permalink to this headline">¶</a></h2>
<p>Up until now we&#8217;ve been concerned with solving a single frame in time.
Now we need to extend that into multiple frames. In the MM Solver there
are <em>animated Attributes</em> that change per-frame and <em>static Attributes</em>
that only have one value. Using <em>static Attributes</em> complicates the
solving process.</p>
<p>If we are to solve only per-frame that would mean Attribute values from
one frame would never affect another frame and therefore we can safely
loop over each frame and solve each frame individually. When including
<em>static Attributes</em>, the <em>static Attributes</em> affect all frames in the
solve.</p>
<p>Consider a simple example; 1 <em>animated Attribute</em> and 1 <em>static
Attribute</em>, solving on three frames, frame 1, 2 and 3. The animated
attribute contains 3 values, an individual value for each frame, and so
each value affects the <em>measured error</em> on each frame. But the <em>static
Attribute</em> contains only one value, not one for each frame, and
therefore the single value affects the <em>measured error</em> on all frames.
To solve for the minimum possible <em>measured error</em> for all values it is
necessary to consider all 4 values together (3 animated values, 1 static
value), and all combinations of the values. Solving for 4 values rather
than 3 values doesn&#8217;t sound like it would take much longer to compute,
but in fact it takes 3 times longer (3 * 3); this problem is squared
each time a static value is added. The more static values added to the
solve increases the number of possible combinations and increases the
number of solver evaluations required for a low <em>measured error</em>.
Solving Animated and Static values as described is a <strong>Brute Force</strong>
approach, but other strategies may be used.</p>
</div>
<div class="section" id="attribute-details">
<span id="solver-design-attribute-details"></span><h2>Attribute Details<a class="headerlink" href="#attribute-details" title="Permalink to this headline">¶</a></h2>
<p>Attribute Details are properties of an Attribute. Attribute Details
are used to add constraints such as value limits.</p>
<p>In mmSolver, there are 4 individual details per-attribute; minimum,
maximum, smoothness and stiffness. See below for more details on how
each property works.</p>
<div class="section" id="minimum-and-maximum-limits">
<h3>Minimum and Maximum Limits<a class="headerlink" href="#minimum-and-maximum-limits" title="Permalink to this headline">¶</a></h3>
<p>Minimum and maximum limits will force <em>mmSolver</em> to solve an attribute
with-in specific values. Attribute min/max limits apply to both static
and animated attributes. If a mnimium or maximum value is not set, the
limit is removed and any value may be used.</p>
<p><em>mmSolver</em> allows a combination of minimum and maximum limits. The
combinations are; minimum only, maximum only, both minimum and
maximum, no to limits at all.</p>
<p>Although min and max limits may appear to be an appealling feature,
often the need to use limits is a sign of problems in your solve.
Minimum and maximum limits are often not helpful because the solver
will simply limit the values used rather than reduce the likely-hood
the solver will try to use values outside the limits.</p>
<p>Minimum and maximum limits are also known as &#8220;Upper and Lower Value
Bounds&#8221;.</p>
</div>
<div class="section" id="smoothness-and-stiffness">
<h3>Smoothness and Stiffness<a class="headerlink" href="#smoothness-and-stiffness" title="Permalink to this headline">¶</a></h3>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/smoothnessConstraintGraph.gif"><img alt="Smoothness Constraint" src="_images/smoothnessConstraintGraph.gif" style="width: 80%;" /></a>
</div>
<p>Smoothness and stiffness ensures a Animated Attribute curve follows a
constraint by increasing the error level of the current solve when the
curve does not behave as expected. By increasing the solver error for
&#8220;bad behaviour&#8221; the solver will automatically try to re-distribute the
error level by changing other Attribute values.</p>
<p>Both <em>smoothness</em> and <em>stiffness</em> use a similar constraint. The solver
will increase the error if the solved value varies by more than the
<em>variance</em> compared to a reference value. This encourages the
solver to reduce &#8220;jumps&#8221; of more than the <em>variance</em> value.</p>
<p>For <em>smoothness</em> constraints, the reference value is a smoothed value
along the curve, based on the previous value. The value at the next
frame is a predicted value, but is allowed to vary.</p>
<p>For <em>stiffness</em> constraints, the reference value is the previous
solved value. This ensures the solver continues to use the same
value. <em>Stiffness</em> is a useful constraint for curves which should stay
flat, but will still vary a little. The focal length of a camera might
be a good example for this type of constraint.</p>
<p>Both <em>smoothness</em> and <em>stiffness</em> constrains have a <em>variance</em> and
<em>weight</em> value for each attribute. The <em>variance</em> value controls how
much the solver can change from the reference value, if the solver
chooses a value that varies by more than the <em>variance</em> a large error
is given to the solver. The <em>weight</em> value controls how strong the
constraint is used inside the solver; lower values means the
<em>stiffness</em> or <em>smoothness</em> has smaller effect, and higher values
increases the effect.</p>
</div>
</div>
<div class="section" id="solver-strategies">
<span id="solver-design-solver-strategies"></span><h2>Solver Strategies<a class="headerlink" href="#solver-strategies" title="Permalink to this headline">¶</a></h2>
<p>Solver strategies are patterns of evaluation that attempt to solve the
input attributes across time while reducing the number of evaluations
and increasing solve quality.</p>
<p>To reduce <em>measured error</em>, the ideal strategy for solves with only
animated attributes is the <strong>Per-Frame</strong> strategy, while the ideal
strategy for animated and static attributes is <strong>All Frames</strong></p>
<ul class="simple">
<li>Per-Frame</li>
<li>Two Frames (Forward / Backward)</li>
<li>Three Frames (Forward / Backward)</li>
<li>All Frames (Brute-force)</li>
</ul>
<p>In practice, a mixture of multiple strategies may be the best approach.</p>
<p>Primary Frames / Root Frames.</p>
<ol class="arabic simple">
<li>Extending the baseline</li>
<li>Hierarchical merging of sub-sequences</li>
<li>Incremental bundle adjustment</li>
</ol>
</div>
<div class="section" id="solver-options">
<span id="solver-design-solver-options"></span><h2>Solver Options<a class="headerlink" href="#solver-options" title="Permalink to this headline">¶</a></h2>
<p>Like many solvers, the MM Solver has options, however the options are
hidden from the Solver UI and are set automatically by the Python API.</p>
<p>To explain the Solver Options below an analogy of climbing a mountain,
to reach the peak (top of the mountain) is used. Our goal is to find
the exact parameters that will bring us to the peak of the
mountain. Our position on the mountain tells us how high we are (the
deviation level), and the direction upwards to the top of the mountain
peak (the gradient or mountain slope).</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/algorithm_steepest_decent.png"><img alt="Mountain Climbing" src="_images/algorithm_steepest_decent.png" style="width: 80%;" /></a>
<p class="caption"><span class="caption-text">Mountain Climbing with Steepest Decent</span></p>
</div>
<div class="section" id="maximum-number-of-iterations">
<span id="solver-design-solver-max-iterations"></span><h3>Maximum Number of Iterations<a class="headerlink" href="#maximum-number-of-iterations" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">integer</span></code></p>
<p>This option does not directly control the number of evaluations
the solver may run, but instead controls how many attempts the
solver will try before giving up.</p>
<p>If the solver attempts to solve more than the maximum iterations the
solve will stop.</p>
</div>
<div class="section" id="tau-initial-damping-factor">
<span id="solver-design-solver-tau"></span><h3>Tau - Initial Damping Factor<a class="headerlink" href="#tau-initial-damping-factor" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">float</span></code></p>
<p>The <em>tau</em> factor determines whether the solver will try to refine the
current parameters a lot (large tau number), or only a small amount
(small tau number). Values usually range between +0.0 and +1.0.</p>
<p>Larger values should be used when the initial unknown parameters
have high error. This forces the Levenberg-Marquet algorithm to use
steepest-decent, rather than gauss-newton.</p>
<p>&#8220;The algorithm is not very sensitive to the choice of &#8216;tau&#8217;, but
as a rule of thumb, one should use a small value, eg &#8216;tau = 10-6&#8217;,
if &#8216;the initial parameters&#8217; are believed to be a good
approximation to the &#8216;final parameter values&#8217;. Otherwise, use &#8216;tau
= 10-3&#8217; or even &#8216;tau = 1.0&#8217;.&#8221;</p>
</div>
<div class="section" id="delta-amount-to-change-parameters">
<span id="solver-design-solver-delta"></span><h3>Delta - Amount to Change Parameters<a class="headerlink" href="#delta-amount-to-change-parameters" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">float</span></code></p>
<p>Delta is the amount of change to the guessed parameters at each
iteration.</p>
<p>Each time the solver guesses an unknown parameter value, it adds
or subtracts the &#8216;delta&#8217; value from the unknown parameter
value. This changes the magnitude of the parameter values in each
guess. If this value is too small, the change in error level may
not be detected, if this value is too large the solver will
over-estimate and will likely lead to poor convergence (the solver
won&#8217;t find a good solution).</p>
</div>
<div class="section" id="epsilon-1-acceptable-gradient-change">
<span id="solver-design-solver-epsilon-one"></span><h3>Epsilon #1 - Acceptable Gradient Change<a class="headerlink" href="#epsilon-1-acceptable-gradient-change" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">float</span></code></p>
<p>The gradient error (sometimes named epsilon #1) is used to find when
the solver has reached the &#8220;top of the mountain peak&#8221;. The gradient
represents the slope of climbing the mountain. When the solver reaches
a (horizontally) flat area of the mountain, then the gradient is low,
and will stop the solve. When the solver can find a slope (gradient),
then the solver can follow the slope of the mountain and reach the top
of the mountain peak.</p>
<p>At the beginning of a solver iteration, if the solver has not
decreased the gradient by at least this value, the solver gives up
trying to reduce the error any more, and stops solving.</p>
</div>
<div class="section" id="epsilon-2-acceptable-parameter-change">
<span id="solver-design-solver-epsilon-two"></span><h3>Epsilon #2 - Acceptable Parameter Change<a class="headerlink" href="#epsilon-2-acceptable-parameter-change" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">float</span></code></p>
<p>The parameter error (sometimes named epsilon #2) is used to determine
the when the solver can stop changing parameter values because the
new parameter values have not changed enough. Changes to parameters are
able to move the solved solution to different places on the mountain,
if the parameter changes are too small then the solver will stop.</p>
<p>At the beginning of a solver iteration, if the guessed parameters do
not change by at least this value, the solver gives up trying to
reduce the error any more.</p>
</div>
<div class="section" id="epsilon-3-acceptable-deviation-error">
<span id="solver-design-solver-epsilon-three"></span><h3>Epsilon #3 - Acceptable Deviation Error<a class="headerlink" href="#epsilon-3-acceptable-deviation-error" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">float</span></code></p>
<p>The deviation error (sometimes named epsilon #3 or deviation) is the
error level that is considered a good solve. To use a mountain
climbing analogy, the <em>deviation error</em> is the highest mountain peak
that is good enough for the solver.</p>
<p>At the beginning of a solver iteration, if the error level is below
this value, the solver considers the error to be low enough for the
user&#8217;s needs and stops trying to reduce the error.</p>
</div>
<div class="section" id="auto-differencing-type">
<span id="solver-design-solver-auto-diff-type"></span><h3>Auto-Differencing Type<a class="headerlink" href="#auto-differencing-type" title="Permalink to this headline">¶</a></h3>
<p>Value type: <code class="docutils literal"><span class="pre">integer</span></code></p>
<p>The strategy used to compute the direction (gradient slope) the solver
should move toward.</p>
<table border="1" class="colwidths-auto docutils" id="id2">
<caption><span class="caption-text">Auto-Differencing Types</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Index</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td><code class="docutils literal"><span class="pre">forward</span></code></td>
<td>Fast but not accurate.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td><code class="docutils literal"><span class="pre">central</span></code></td>
<td>More accurate but 1/3rd slower to compute initially.</td>
</tr>
</tbody>
</table>
<p>In practice, the authors of mmSolver have found <code class="docutils literal"><span class="pre">central</span></code>
dramatically slows down the solver and does not increase accuracy very
much. It is therefore recommended to use <code class="docutils literal"><span class="pre">forward</span></code>.</p>
</div>
</div>
<div class="section" id="general-solving-concepts">
<h2>General Solving Concepts<a class="headerlink" href="#general-solving-concepts" title="Permalink to this headline">¶</a></h2>
<p><strong>To be written</strong></p>
<div class="section" id="over-parameterization">
<h3>Over-Parameterization<a class="headerlink" href="#over-parameterization" title="Permalink to this headline">¶</a></h3>
<p>Parameters-errors ratio is too high.</p>
<p><strong>To be written</strong></p>
</div>
<div class="section" id="plane-line-and-curve-constraints">
<h3>Plane, Line and Curve Constraints<a class="headerlink" href="#plane-line-and-curve-constraints" title="Permalink to this headline">¶</a></h3>
<p><strong>To be written</strong></p>
</div>
</div>
<div class="section" id="frequently-asked-questions-faq">
<span id="solver-faq-heading"></span><h2>Frequently Asked Questions (FAQ)<a class="headerlink" href="#frequently-asked-questions-faq" title="Permalink to this headline">¶</a></h2>
<p>Below are the some common questions and answers.</p>
<div class="section" id="how-do-i-get-the-list-of-supported-solver-types">
<span id="solver-faq-how-to-get-supported-solver-types"></span><h3>How do I get the list of supported Solver Types?<a class="headerlink" href="#how-do-i-get-the-list-of-supported-solver-types" title="Permalink to this headline">¶</a></h3>
<p>To dynamically get the supported list of solver types, run this Python
command in Maya:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maya</span><span class="o">.</span><span class="n">cmds</span><span class="o">.</span><span class="n">loadPlugin</span><span class="p">(</span><span class="s1">&#39;mmSolver&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maya</span><span class="o">.</span><span class="n">cmds</span><span class="o">.</span><span class="n">mmSolverType</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[u&#39;1=cminpack_lmdif&#39;, u&#39;2=cminpack_lmder&#39;]   # Example output.</span>
</pre></div>
</div>
<p>The full list of solver types supported are listed below. Please note
that depending on compilation, some solver types will not be available.</p>
<table border="1" class="colwidths-auto docutils" id="id3">
<caption><span class="caption-text">Solver Types</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Index</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td><code class="docutils literal"><span class="pre">levmar</span></code></td>
<td>Use <a class="reference external" href="http://users.ics.forth.gr/~lourakis/levmar/">levmar</a> library with the <code class="docutils literal"><span class="pre">levmar_bc_dif</span></code> function.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td><code class="docutils literal"><span class="pre">cminpack_lmdif</span></code></td>
<td>Use <a class="reference external" href="http://devernay.free.fr/hacks/cminpack/index.html">CMinpack</a> library with the <a class="reference external" href="http://devernay.free.fr/hacks/cminpack/lmdif_.html">lmdif</a> function.</td>
</tr>
<tr class="row-even"><td>2</td>
<td><code class="docutils literal"><span class="pre">cminpack_lmder</span></code></td>
<td>Use <a class="reference external" href="http://devernay.free.fr/hacks/cminpack/index.html">CMinpack</a> library with the <a class="reference external" href="http://devernay.free.fr/hacks/cminpack/lmder_.html">lmder</a> function.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="what-transform-space-is-used-for-solving">
<span id="solver-faq-what-transform-space-is-used-for-solving"></span><h3>What transform space is used for solving?<a class="headerlink" href="#what-transform-space-is-used-for-solving" title="Permalink to this headline">¶</a></h3>
<p><em>MM Solver</em> evaluates all <em>Marker</em> and <em>Bundle</em> screen-space errors in
<strong>world-space</strong>, but solving is not performed in a transform space.
Solving is performed directly on <em>Attribute</em> values.</p>
</div>
<div class="section" id="how-can-i-use-a-dag-hierarchy-to-reduce-the-number-of-attributes">
<span id="solver-faq-how-to-reduce-attribute-count-with-dag"></span><h3>How can I use a DAG hierarchy to reduce the number of <em>Attributes</em>?<a class="headerlink" href="#how-can-i-use-a-dag-hierarchy-to-reduce-the-number-of-attributes" title="Permalink to this headline">¶</a></h3>
<p><strong>To be written</strong></p>
</div>
<div class="section" id="how-can-i-make-my-solves-faster">
<span id="solver-faq-how-to-increase-solve-speed"></span><h3>How can I make my solves faster?<a class="headerlink" href="#how-can-i-make-my-solves-faster" title="Permalink to this headline">¶</a></h3>
<p><strong>To be written</strong></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solver Design</a><ul>
<li><a class="reference internal" href="#how-does-the-solver-work">How does the solver work?</a></li>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
<li><a class="reference internal" href="#markers-and-bundles">Markers and Bundles</a></li>
<li><a class="reference internal" href="#solving">Solving</a></li>
<li><a class="reference internal" href="#solving-process">Solving Process</a></li>
<li><a class="reference internal" href="#time-static-and-animated-attributes">Time - Static and Animated Attributes</a></li>
<li><a class="reference internal" href="#attribute-details">Attribute Details</a><ul>
<li><a class="reference internal" href="#minimum-and-maximum-limits">Minimum and Maximum Limits</a></li>
<li><a class="reference internal" href="#smoothness-and-stiffness">Smoothness and Stiffness</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solver-strategies">Solver Strategies</a></li>
<li><a class="reference internal" href="#solver-options">Solver Options</a><ul>
<li><a class="reference internal" href="#maximum-number-of-iterations">Maximum Number of Iterations</a></li>
<li><a class="reference internal" href="#tau-initial-damping-factor">Tau - Initial Damping Factor</a></li>
<li><a class="reference internal" href="#delta-amount-to-change-parameters">Delta - Amount to Change Parameters</a></li>
<li><a class="reference internal" href="#epsilon-1-acceptable-gradient-change">Epsilon #1 - Acceptable Gradient Change</a></li>
<li><a class="reference internal" href="#epsilon-2-acceptable-parameter-change">Epsilon #2 - Acceptable Parameter Change</a></li>
<li><a class="reference internal" href="#epsilon-3-acceptable-deviation-error">Epsilon #3 - Acceptable Deviation Error</a></li>
<li><a class="reference internal" href="#auto-differencing-type">Auto-Differencing Type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-solving-concepts">General Solving Concepts</a><ul>
<li><a class="reference internal" href="#over-parameterization">Over-Parameterization</a></li>
<li><a class="reference internal" href="#plane-line-and-curve-constraints">Plane, Line and Curve Constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</a><ul>
<li><a class="reference internal" href="#how-do-i-get-the-list-of-supported-solver-types">How do I get the list of supported Solver Types?</a></li>
<li><a class="reference internal" href="#what-transform-space-is-used-for-solving">What transform space is used for solving?</a></li>
<li><a class="reference internal" href="#how-can-i-use-a-dag-hierarchy-to-reduce-the-number-of-attributes">How can I use a DAG hierarchy to reduce the number of <em>Attributes</em>?</a></li>
<li><a class="reference internal" href="#how-can-i-make-my-solves-faster">How can I make my solves faster?</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tools_hotkeys.html"
                        title="previous chapter">Hotkeys</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nodes.html"
                        title="next chapter">Nodes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/solver_design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nodes.html" title="Nodes"
             >next</a> |</li>
        <li class="right" >
          <a href="tools_hotkeys.html" title="Hotkeys"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mayaMatchMoveSolver master documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, 2019, David Cattermole, Anil Reddy..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>